/* FILE CONTAINS:  Lecture 10.
1- C STRING CONCEPT

C-String Lenght Concept - 25 character name

const int NAME_SIZE = 25;
char name[NAME_SIZE + 1]; // as it contain null character at the end.

strcpy(name, "");
    // OR
    name[0] = '\0';

// C-String - 62 character address then
const int ADDRESS_SIZE = 62;
char address[ADDRESS_SIZE];

2- USAGE OF COPY CONSTRUCTOR
    CC Case 1: Whenever an object is of your class is passed into a function BY VALUE.
    CC Case 2: Whenever an object of your class is created and assigned to the object of same type.
    CC Case 3: Whenever an object of your class is returned BY VALUE from a function.


3- SHALLOW  COPY/ DEEP COPY
4- this Pointer.




*/

#include <iostream>
#include <fstream>
#include <cstring>
#include "Point.cpp"
using namespace std;

// Test Class for studying COPY CONSTRUCTORS.
class Test
{
private:
    int val;
    int *p;

public:
    Test() : val(0) // This is called Member Initialization/Initializer List. (Pointers can't be initialized by this list)
    {
        // val = 0;
        p = new int;
        *p = 0;
        // cout << "Created through Default constructor: " << val << " " << *p << endl;
        //  this pointer: default pointer in every function of the class and it is called explicitly.
        cout << "Created through Default constructor: " << this << endl;
    }

    Test(int v1, int v2) : val(v1) // This is done only in case of constructors and one other function will be discussed later.
    {
        // val = v;
        p = new int;
        *p = v2;
        // cout << "Created through Parameter constructor: " << val << " " << *p << endl;
        cout << "Created through Parameter constructor: " << this << endl;
    }
    // COPY CONSTRUCTOR OF TEST CLASS.
    Test(const Test &orig)
    {
        // cout << "Copy Constructor Called!!" << endl;
        cout << "Copy Constructor Called!!" << this << endl;
        val = orig.val;
        // p = orig.p;   // This is again a Shallow Copy.

        //  MAKING THE DEEP COPY OF THAT POINTER

        p = new int;
        *p = *(orig.p);
    }
    void setVal(int temp)
    {
        val = temp;
    }
    void display() const
    {
        cout << "Value: " << val << endl;
        cout << "Pointer: " << *p << endl;
    }
    // Destructor
    // Telda sign and name same as class.
    // Each Class has only one destructor.
    // Destructor are called in reverse order.

    ~Test()
    {
        // cout << "Destructor Called!!!  " << val << " " << *p << endl;
        cout << "Destructor Called!!!  " << this << endl;

        // De-Allocation with the check whether dynamic memory was created or not.
        if (p != nullptr)
        {
            delete p;
            p = nullptr;
        }
    }
};

// Global Function

/*void displayPoint(const Point &p)   // -> Recieving const Point object by REFERENCE
{
   //  p.setX(0);    can't called because object is been passed as constant reference
                     // And Global function also can not be constant.
    cout << "Address of p: " << &p << endl;
    p.displayPoint();
}*/

void displayPoint(Point temp) // ->  Recieving const Point object by VALUE
{
    cout << "Address of temp: " << &temp << endl;
    temp.displayPoint();

    // A COPY CONSTRUCTOR has been automatically generated by the compiler for this copied object.
    // i.e. pt1 is been copied as it is in context of p here hence destructor will be called for tis sort of object.
    // Bit-Wise COPY / byte-by-byte COPY. / SHALLOW  COPY.
}
// void displayTest(const Test &t) // BY REFERENCE
// {
//     t.display();
// }
void displayTest(Test temp) // BY VALUE - Copy will be made.
{
    // A RUNTIME ERROR will be faced as t is created as the copy (SHALLOW COPY) of t1 so it copy its content also pointer p
    // which is pointing to the same memory location as t.
    temp.display();
}
int main()
{

    // Point pt1(40, 50);
    // cout << "Address of Pt1: " << &pt1 << endl;
    // CC Case 1 DISSCUSSED *****
    // displayPoint(pt1);.
    // cout << "Back in main\n";

    //--------------------------------------------------------------------------------------------------

    Test t1(33, 23);
    // CC Case 1 DISSCUSSED ******
    // displayTest(t1);
    //  cout << "Back in main\n";

    // USAGE OF COPY CONSTRUCTOR - CC Case 2 DISSCUSSED ****

    Test t2 = t1;
    //  OR
    // Test t2(t1);
    //  OR
    // Test t2 = {t1};
    // This won't create a copy
    // Test t2;
    // t2 = t1;

    // ----------------------------------------------------------------------------------------------
    /*
    int n;
    cout << "Enter the Number of points you want to create? : ";
    cin >> n;
    Point *pts = new Point[n];
    int x, y;
    for (int i = 0; i < n; i++)
    {

        cout << "Enter Coordinates of Point no. " << i + 1 << " : ";
        cin >> x;
        cin.ignore(); // ignore the comma.
        cin >> y;

        pts[i].setCoordinates(x, y);
    }*/

    // for (int i = 0; i < n; i++)
    // {
    //     cout << "\n Point " << i + 1 << " is: ";
    //     pts[i].displayPoint();
    // }

    // File handling using objects and classes - writting in the file.

    /* ofstream fout;
     fout.open("Points.txt");
     if (!fout)
     {
         cout << "Error: Cannot open file " << endl;
     }
     else
     {
         fout << n << endl;
         for (int i = 0; i < n; i++)
         {
             // fout << "\n Point " << i + 1 << " is: ";
             /*int v1 = pts[i].getX();
             int v2 = pts[i].getY();
             fout << v1 << "," << v2 << endl;*/
    // this displaying method is tough for large no of functions.

    //         pts[i].writeToFile(fout);
    //     }
    //     fout.close();
    // }

    // delete[] pts;
    // pts = nullptr;

    // Reading content of the file.

    /* ifstream fin;
     fin.open("Points.txt");
     if (!fin)
     {
         cout << "Error: Couldn't open file!!" << endl;
     }
     else
     {
         int numPoints;
         fin >> numPoints;
         Point *points = new Point[numPoints];
         for (int i = 0; i < numPoints; i++)
         {
             // int x, y;
             // fin >> x >> y;
             // points[i].setCoordinates(x, y);

             points[i].readFromFile(fin);
         }
         fin.close();
         for (int i = 0; i < numPoints; i++)
         {
             // int x, y;
             // fin >> x >> y;
             // points[i].setCoordinates(x, y);

             points[i].displayPoint();
         }
         delete[] points;
         points = nullptr;
     }*/

    // -------------------------------------------------------------------------------------------------------------------------

    /*
    Point pt1; // At the time of creating object ot instance they contain junk values.
               // so we implement a function called constructor to set some default values.
               // Default constructor automatically called while creating object.
    Point pt2(3, 4);
    const int N = 3;
    Point pt3[N] = {{2, 3}, {4, 5}}; // Inilization method used for only statically allocated arrays.

    Point pt4(7);

    pt1.displayPoint();

    pt2.displayPoint();

    for (int i = 0; i < N; i++)
    {
        pt3[i].displayPoint();
    }

    pt4.displayPoint();

    const Point origin(0, 0);
    // origin.setX(2);   // ERROR: Non Const function can't be called.
    origin.displayPoint();

    /*Point p1; // p1 is an object/instance of class Point.
    // p1.x = 10;   // ERROR: Private members are inaccessible
    // p1.y = 11;    // ERROR: Private members are inaccessible

    p1.setX(5);
    p1.setY(10);
    cout << "P1 Contains: ";
    cout << p1.getX() << " " << p1.getY() << endl;

    Point p2;

    int tempX, tempY;
    cout << "Enter Coordinates: ";
    cin >> tempX >> tempY;
    p2.setX(tempX);
    p2.setY(tempY);

    cout << "P2 Contains: ";
    cout << p2.getX() << " " << p2.getY();

    // Creating objects on HEAP

    Point *ptr = new Point;
    //(*ptr).setX(50);
    // OR
    ptr->setX(50);
    ptr->setY(60);

    cout << "\nPoints on Heap are: ";
    // cout << ptr->getX() << " " << ptr->getY() << endl;
    ptr->displayPoint();

    delete ptr;
    ptr = nullptr; */

    // ARRAY of Points

    // const int N = 4;
    //  Point pts[N];

    // Creating Dynamically Allocated Array of Points

    /*int n;
    cout << "Enter the Number of points you want to create? : ";
    cin >> n;
    Point *pts = new Point[n];
    for (int i = 0; i < n; i++)
    {
        int a, b;
        cout << "Enter Coordinates of Point no. " << i + 1 << " : ";
        cin >> a >> b;
        // pts[i].setX(a);
        // pts[i].setY(b);

        pts[i].setCoordinates(a, b);
    }

    for (int i = 0; i < n; i++)
    {
        cout << "\n Point " << i + 1 << " is: ";
        pts[i].displayPoint();
    }

    delete[] pts;
    pts = nullptr;*/

    return 0;
}